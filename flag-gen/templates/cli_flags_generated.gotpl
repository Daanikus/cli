// Code generated by fg; DO NOT EDIT.

package {{ .PackageName }}

import (
	"flag"
	"fmt"
	"regexp"
	"strconv"
	"time"
)
{{ range $i, $flag := .Flags }}
// {{ $flag.Name }}Flag is a flag with type {{ $flag.Type }}{{ $flag.Doctail }}
type {{ $flag.Name }}Flag struct {
	Name			string
	Usage			string
	EnvVar			string
	FilePath		string
	Required		bool
	Hidden			bool
	{{- if eq $flag.Value true }}
	Value			{{ $flag.Type }}
	{{- end }}
	{{- if eq $flag.Destination true }}
	Destination		*{{ $flag.Type }}
	{{- end }}
	{{- range $i, $v := .Validators }}
	{{- if eq $v "regexp" }}
	{{ $v | title }} 			*regexp.Regexp
	{{- else if eq $v "custom" }}
	CustomValidator	func({{ $flag.Type }}) error
	{{- else }}
	{{ $v | title }}				*{{ $flag.Type }}
	{{- end }}
	{{- end }}
}

// String returns a readable representation of this value
// (for usage defaults)
func (f {{ $flag.Name }}Flag) String() string {
	return FlagStringer(f)
}

// GetName returns the name of the flag
func (f {{ $flag.Name }}Flag) GetName() string {
	return f.Name
}

// IsRequired returns whether or not the flag is required
func (f {{ $flag.Name }}Flag) IsRequired() bool {
	return f.Required
}

// TakesValue returns true of the flag takes a value, otherwise false
func (f {{ $flag.Name }}Flag) TakesValue() bool {
	return {{ $flag.Value }}
}

// GetUsage returns the usage string for the flag
func (f {{ $flag.Name }}Flag) GetUsage() string {
	return f.Usage
}

// GetValue returns the flags value as string representation and an empty
// string if the flag takes no value at all.
func (f {{ $flag.Name }}Flag) GetValue() string {
	{{ $flag.ValueString }}
}

{{- if .Validators }}
// Validate returns an error if the flag does not pass the validation criteria
// defined by the user
func (f {{ $flag.Name }}Flag) Validate(val interface{}) error {
	value := val.({{ $flag.Type }})

	{{- range $i, $v := .Validators }}
	{{- if eq $v "regexp" }}
	if f.Regexp != nil && !f.Regexp.MatchString(value) {
		return fmt.Errorf("value of flag %s is not valid. got %v", f.GetName(), value)
	}
	{{- else if eq $v "custom" }}
	if f.CustomValidator != nil {
		if err := f.CustomValidator(value); err != nil {
			return err
		}
	}
	{{- else if eq $v "min"}}
	if f.Min != nil && value < *f.Min {
		return fmt.Errorf("value of %s flag should have a minimum value of %v. got %v", f.Name, *f.Min, value)
	}
	{{- else if eq $v "max"}}
	if f.Max != nil && value > *f.Max {
		return fmt.Errorf("value of %s flag should have a maximum value of %v. got %v", f.Name, *f.Max, value)
	}
	{{- end }}
	{{- end }}
	return nil
}
{{- end }}

// {{ $flag.Name }} looks up the value of a local {{ $flag.Name }}Flag, returns
// {{ $flag.ContextDefault }} if not found
func (c *Context) {{ $flag.Name }}(name string) {{ if ne .ContextType "" }}{{ $flag.ContextType }}{{ else }}{{ $flag.Type }}{{- end }} {
	return lookup{{ $flag.Name }}(name, c.flagSet)
}

// Global{{ $flag.Name }} looks up the value of a global {{ $flag.Name }}Flag, returns
// {{ $flag.ContextDefault }} if not found
func (c *Context) Global{{ $flag.Name }}(name string) {{ if ne .ContextType "" }}{{ $flag.ContextType }}{{ else }}{{ $flag.Type }}{{- end }} {
	if fs := lookupGlobalFlagSet(name, c); fs != nil {
		return lookup{{ $flag.Name }}(name, fs)
	}
	return {{ $flag.ContextDefault }}
}

func lookup{{ $flag.Name }}(name string, set *flag.FlagSet) {{ if ne .ContextType "" }}{{ $flag.ContextType }}{{ else }}{{ $flag.Type }}{{- end }} {
	f := set.Lookup(name)
	if f != nil {
		{{ if ne .Parser "" }}parsed, err := {{ $flag.Parser }}{{ else }}parsed, err := f.Value, error(nil){{ end }}
		if err != nil {
			return {{ $flag.ContextDefault }}
		}
		{{ if ne .ParserCast "" }}return {{ $flag.ParserCast }}{{ else }}return parsed{{ end }}
	}
	return {{ $flag.ContextDefault }}
}
{{ end }}
